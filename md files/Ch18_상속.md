# Chapter18 상속  

- **상속**은 스위프트의 다른 타입과 클래스를 구별 짓는 **클래스만의 특징**이다.
- 상속받은 클래스는 **자식클래스(Subclass/Child-class)**  
  자식클래스에게 자신의 특성을 물려준 클래스를 **부모클래스(Superclass, Parents-class)**라고 표현한다.  
- 상속받은 프로퍼티에 프로퍼티의 값이 변경되면 알려주는 프로퍼티 감시자도 구현할 수 있다.  

  > 연살 프로퍼티를 정의해준 클래스에서는 연산 프로퍼티에 프로퍼티 감시자를 구현할 수 없지만,  
  > 부모클래스에서 연산 프로퍼티로 정의가 된 프로퍼티든 저장 프로퍼티로 정의가 된 프로퍼티든 간에  
  > 자식클래스에서는 프로퍼티 감시자를 구현할 수 있다.  
- 다른 클래스로부터 상속을 받지 않은 클래스를 **기반클래스(Base class)**라고 부른다.  


## 18.1 클래스 상속  

```swift
class name: superClass {
	properties and methods
}
```

## 18.2 재정의(Override)  
- 부모클래스로부터 물려받은 특성(인스턴스 메서드, 타입 메서드, 인스턴스 프로퍼티, 타입 프로퍼티, 서브스크립트 등)을 그대로 사용하지 않고 자신만의 기능으로 변경하여 사용하는 것  
- **override** 라는 키워드를 사용하여 재정의한다.  
- 만약 조상클래스(부모를 포함한 그 상위 부모클래스)에 재정의할 해당 특성이 없는데 override 키워드를 사용하면 컴파일 오류 발생  

- 만약 자식클래스에서 부모클래스의 특성을 재정의하였을 때, 부모클래스의 특성을 자식클래스에서 사용하고 싶다면 **super** 프로퍼티를 사용하면 된다. 즉, 자식클래스에서 특성을 재정의 하였지만 필요에 따라 부모클래스의 특성을 활용하고 싶을 때 super를 사용한다.  
	- 당연히도 super키워드를  
	  **타입 메서드 내에서 사용**한다면, 부모클래스의 **타입 메서드**와 **타입 프로퍼티**에 접근할 수 있으며  
	  **인스턴스 메서드 내에서 사용**한다면, 부모클래스의 **인스턴스 메서드**와 **인스턴스 프로퍼티**, **서브스크립트**에 접근할 수 있다.  

	- 재정의된 someMethod()의 부모 버전을 호출하고 싶다면 super.someMethod()라고 호출하면 되고,  
	  재정의된 someProperty의 부모 버전에 접근하고 싶다면 super.someProperty라고 접근하면 되며,  
	  재정의된 서브스크립트에서 부모 버전의 서브스크립트로 접근하고 싶다면 super[index]라고 접근하면 된다.  
	  
### 18.2.1 메서드 재정의  
- 일반적으로 아는 것과 같음. 쓸게 없음.

### 18.2.2 프로퍼티 재정의  
- 프로퍼티를 재정의한다는 것은 프로퍼티 자체가 아니라 프로퍼티의 접근자(Getter), 설정자(Setter), 프로퍼티 감시자(Property Observer) 등을 재정의하는 것을 의미한다.  
	- 즉, 프로퍼티를 재정의할 때에는 저장 프로퍼티로 재정의할 수는 없다.
	- 프로퍼티를 상속받은 자식클래스에서는 조상클래스의 프로퍼티의 종류(저장, 연산)는 알지 못하고 단지 이름과 타입만을 알고 있기 때문에  
	  조상클래스에서 저장 프로퍼티로 정의된 프로퍼티는 물론이고, 연산 프로퍼티로 정의된 프로퍼티도 접근자, 설정자를 재정의할 수 있다.  
	- 조상클래스에서 읽기 전용 프로퍼티였더라도 자식클래스에서 읽고 쓰기가 가능한 프로퍼티로 재정의해줄 수도 있다.  
	  그러나 읽기 쓰기 모두 가능했던 프로퍼티를 읽기 전용으로 재정의해줄 수는 없다.  

### 18.2.3 프로퍼티 감시자 재정의  
- 프로퍼티 감시자도 프로퍼티의 접근자와 설정자처럼 재정의할 수 있으며,  
  이 역시 조상클래스에서 정의된 프로퍼티가 연산 프로퍼티인지 저장 프로퍼티인지는 상관 없다.  
  
  다만, 상수 저장 프로퍼티나 읽기 전용 연산 프로퍼티는 프로퍼티 감시자를 재정의할 수 없다.  
  왜냐하면 상수 저장 프로퍼티나 읽기 전용 연산 프로퍼티는 값을 설정할 수 없으므로 willSet이나 didSet메서드를 사용한 프로퍼티 감시자가 원천적으로 사용이 불가능하기 때문이다.
- 프로퍼티 감시자를 재정의하더라도 조상클래스에 정의된 프로퍼티 감시자도 동작한다.
- 프로퍼티의 접근자와 감시자는 동시에 재정의할 수 없다.  
  만약 둘 다 동작되길 원한다면 재정의하는 접근자에 프로퍼티 감시자의 역할을 구현해야 한다.

```swift
import Swift

// 코드 18-6 프로퍼티 감시자 재정의
class Person {
    var name: String = ""
    var age: Int = 0 {
        didSet {
            print("Person age : \(self.age)")
        }
    }
    var koreanAge: Int {
        return self.age + 1
    }
    
    var fullName: String {
        get {
            return self.name
        }
        
        set {
            self.name = newValue
        }
    }
}

class Student: Person {
    var grade: String = "F"
    
    override var age: Int {
        didSet {
            print("Student age : \(self.age)")
        }
    }
    
    override var koreanAge: Int {
        get {
            return super.koreanAge
        }
        
        set {
            self.age = newValue - 1
        }
        
        // didSet {  }  // 오류발생!!
    }
    
    override var fullName: String {
        didSet {
            print("Full Name : \(self.fullName)")
        }
    }
}

let yagom: Person = Person()
yagom.name = "yagom"
yagom.age = 55  // Person age : 55
yagom.fullName = "Jo yagom"
print(yagom.koreanAge)  // 56


let jay: Student = Student()
jay.name = "jay"
jay.age = 14					// 감시자 모두 동작
// Person age : 14
// Student age : 14
jay.koreanAge = 15			// 감시자 모두 동작
// Person age : 14
// Student age : 14
jay.fullName = "Kim jay"    // Full Name : Kim jay
print(jay.koreanAge)    // 15

```  

### 18.2.4 서브스크립트 재정의  
- 특이점 없음, 생략  

### 18.2.5 재정의 방지  
- 재정의를 방지하고 싶은 특성 앞에 **final** 키워드를 명시하여 재정의를 방지할 수 있다.  
- 클래스를 상속하거나 재정의할 수 없도록 class 앞에 final 키워드를 명시할 수도 있다.  
  (더이상 자식클래스를 가질 수 없는 클래스가 되어버림...)  


## 18.3 클래스의 이니셜라이저 - 상속과 재정의  
